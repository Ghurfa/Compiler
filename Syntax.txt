out parameter
semicolons ?
tuples
why not type inference for local vars?

Code block statement as anonymous function
combining binary expressions
    bool x = y$(>2 && <5)
    bool x = $(y || z) < 12
    bool x = 
    === Switch expression ===
a:bool = y switch {
    12, _ -> true,
    14 -> false
    }

=== Fix if expression ===
Current: Type a = true ? Paddle:Ball
		Would be parsed as condition ? Declaration [missing : token}
a = if(true) Paddle else Ball
	verbose
a =  true ? Paddle \ true ? Ball \ null
	Visually splits apart the statements
    Should backslash be reserved?
	a = true ? Paddle
		\ true ? Ball

=== Reconsider colon marking variable declaration ===
    Named parameters
    If expressions
    if(a is b:B)
    
=== Is Expression ===
    c#: if(a is B b)
    current: if(?(b:B as a))
    if(a is b:B)
        [a is] (identifier) (token)
            >declarator
            >type
    
=== Null Check Operators ===
    a?.b = a == null ? null \ a.b
    a?[b] = a == null ? null \ a[b]
    a ?? b = a != null ? a \ b
    a ??= b = a != null ? a \ a = b
    
    ?a = a != null
    
=== Throw Expression ===
    a ?? throw new InvalidOperationException()

=== Short if/else stack ===
    Something like
        ? a == 2 -> return true
        \ b -> {t++; return false}
    isn't a huge improvement over normal if/else

=== Enforce semicolon if same line ===

=== Lambdas ===
    Statement and expressions
    
=== Multiple key switch ===
switch(val1, val2)
{
case 18, 19:
break;
}
Should just be switch on tuple?

=== Built in Types ===
Built in lists
    [1, 2, 3, 4]
Built in ordered lists (sequences)
    Should just be lists?
Built in dictionaries
    [1 -> true, 
     2 -> false]
Built in enumerables

=== Tuples ===
=== Tiered Namespaces ===
=== Null & Default Keywords ===
=== Default operator ===

=== Linq ===
    intArr where num:int
    
=== Actions and Funcs ===

=== Local Functions ===

=== Combining expressions ===
bool x = y$(>=0 && <100)

=== Cleaner Constructor Syntax ===
    Calling syntax isn't that bad; not a priority
    Declaration
        
    Calling
        a := new Xyz()

=== Harder/Less useful stuff ===
Python * (repeat for every item in array)
Multiple inheritances (ruby modules?)
Code block statement as anonymous function
?: cast operator
Unions

problem w/ how symbols are tokenized
    genericThing<thing<int>>
    }} operator breaks two curly braces
    something like ::> couldn't be parsed if :: is not defined

    make tokentypes more specific
    convert tokens text to spans (better space)


myArray int[4] = {101, 102, 103, 104},

i := 0

(condition)
?

;

()
{

}
=== Field Declarations ===
myVar:Modifiers Type
	x:int
	x:public myClass
myVar = DefaultVal : Modifiers Type
	x : public static int = 2 
	x : public myClass = new myClass() 
	x : public int = getX(12) 
myVar := DefaultVal : Modifiers
    x := 2 : public static
    x := 2 ;
    See https://docs.microsoft.com/en-us/archive/blogs/ericlippert/why-no-var-on-fields

=== Property Declarations ===
myProp => expression : Modifiers Type
	getX => x : public static int
myProp :> expression : Modifiers
	getX :> 17 : public static
myProp {get set stuff}

=== Method Declarations ===
myMethod public static int(param1:type1, param2:type2, param3:out type3) {statements}
	add public static int(a:int, b:int)
	{

	}

===Expressions===
expr operator expr
expr  "?"  expr  ":"  expr
unaryExpr assignmentOperator expr
Cast Expression
    unaryExpr "as" type
        myDouble:double = myFloat as double 
        myFloat:float = (myDouble as int) as float
Unary Expression
    +unaryExpr
    -unaryExpr
    ++unaryExpr
    --unaryExpr
    !unaryExpr
    ~unaryExpr
    *unaryExpr
    Primary Expression
        Tuple Expression
            "(" {expr + ","}+ ")"
        Literal
            int literal
                hexadecimal
            string literal
            char literal
        "new"  type  "("  arguments  ")"
            public class B {
                static int staticVal;
                int val;
                public B(int val) => this.val = val;
                public void SetBStaticVal() => staticVal = val;
            }
            public class C {
                public void M() {
                    new B(2).SetBStaticVal();
                }
            }
        "new"  type  "["  count?  "]"
        "("  expr  ")"
        "this"
        "typeof"  "("  type  ")"
        Assignable Expression
            identifier
            primaryExpr  "("  arguments  ")"
            primaryExpr  "."  identifier
            predefinedType  "."  identifier
            "base"  "."  identifier
            "base"  "["  expressions  "]"
            primaryExpr  "["  expressions  "]"
            primaryExpr++                       should include?
            
        Complete Expression
            primaryExpr  "("  arguments  ")"    duplicate
            primaryExpr++
                num++.ToString();
            primaryExpr--
===Statement Expressions===
    completeExpression
    ++primaryExpression         should allow?
        conflict:
            a++
            ++b (possible, but hard to parse)
    --primaryExpression
    unaryExpr assignment expression (spec)
        ???
        ++a += 2   (won't include)
    assignableExpr assignment expression

===Statements===
Variable Declaration
    {identifier "," }+  ":"  type
	    a:int
        a,b,c:int
    {identifier "," }+  ":="  expression  ";"
	    a := 3;
	    a,b,c := 3;
    {identifier "," }+  "="  expression  ":" type
        a = null : Ball
Tuple Declarations
    Should not allow? Non-named tuples not useful
        (a,b):(int, int)
        (a,b) = (2, 3) : (int, int)
        (a,b) := (2, 3)
    Normal var declarations
        c = (a, b) : (int, int)
        c := (a, b)
Code Block
    "{"  statement+  "}"
    ";"
Control Block
    "if"  "("  condition  ")"  codeBlock
    "switch"  "("  expression  ")"  switchCodeBlock
    "while"  "("  condition  ")"  codeBlock
    "for"  "("  statement statement statement  ")"  codeBlock
    "foreach"  "("  identifier  ":"  type  "in"  expression  ")"  codeBlock
Jump Statement
    "break"
    "continue"
    "return"
        needs semicolon?
            return 
            a.func()
            would need to check return type
    "exit"
        void return?
    "throw"
Statement Expression
    statementExpression  ";"